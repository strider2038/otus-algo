---
theme: cern
---

## Алгоритм на конечных автоматах для разбора поисковых запросов промышленных стандартов

Игорь Лазарев,
техлид istock.info

---

## Основная идея алгоритма

Алгоритм используется для разбора названий промышленных стандартов

- Подшипник роликовый тип 102000 исп.1 ГОСТ 8328-75
- Винт с полупотайной головкой ГОСТ Р ИСО 7047 М5х20-4.8-Z
- Шайба класса точности C ГОСТ 11371-78

---

## Пример разбора запроса

"Подшипник роликовый тип 102000 исп.1 ГОСТ 8328-75"

- слово **подшипник**
- слово **роликовый**
- код типа **102000**
- код исполнения **1**
- код стандарта типа **ГОСТ** с номером **8328-75**

---

## План

- Применение алгоритма Ахо-Корасика, определение переходов по суффиксным ссылкам
- Изучить алгоритм, написать пример с одним текстовым паттерном
- Паттерн с вариативной частью
- Паттерн с переходами по суффиксным ссылкам
- Множество паттернов
- Бенчмарк-тесты, профилирование и сравнение с примитивной реализацией

---

## Применимость алгоритма Ахо-Корасика

Изначальной идеей было использование алгоритма Ахо-Корасик для обнаружения нескольких паттернов. В процессе работы выяснилось, что напрямую алгоритм к данной задаче не применим. Поэтому остановился на варианте использования нескольких конечных автоматов.

---

## Общая суть алгоритма

Итеративно пытаться выделить паттерны из текста по приоритету:

- код стандарта (например, "ГОСТ 8328-75")
- код типа (например, "тип А")
- код исполнения (например, "исп.1", "исполнение 2")
- код класса точности (например, "класс точности С")
- слово на естественном языке (например, "болт")
- обобщенный шифр (например, "М5х20-4.8-Z")

---

### Пример работы алгоритма (1)

<u>Подшипник</u> роликовый тип 102 исп.1 ГОСТ 8328-75 М5х20-4.8-Z

- [ ] код стандарта (начинается с "ГОСТ", "DIN", ...)
- [ ] код типа (начинается с "тип", "типа", ...)
- [ ] код исполнения (начинается с "исп.", "исполнение", ...)
- [ ] код класса точности (начинается с "класс точности", ...)
- [x] слово на естественном языке (только кириллица/латиница)
- [ ] обобщенный шифр (все остальное)

---

### Пример работы алгоритма (2)

Подшипник <u>роликовый</u> тип 102 исп.1 ГОСТ 8328-75 М5х20-4.8-Z

- [ ] код стандарта (начинается с "ГОСТ", "DIN", ...)
- [ ] код типа (начинается с "тип", "типа", ...)
- [ ] код исполнения (начинается с "исп.", "исполнение", ...)
- [ ] код класса точности (начинается с "класс точности", ...)
- [x] слово на естественном языке (только кириллица/латиница)
- [ ] обобщенный шифр (все остальное)

---

### Пример работы алгоритма (3)

Подшипник роликовый <u>тип 102</u> исп.1 ГОСТ 8328-75 М5х20-4.8-Z

- [ ] код стандарта (начинается с "ГОСТ", "DIN", ...)
- [x] код типа (начинается с "тип", "типа", ...)
- [ ] код исполнения (начинается с "исп.", "исполнение", ...)
- [ ] код класса точности (начинается с "класс точности", ...)
- [ ] слово на естественном языке (только кириллица/латиница)
- [ ] обобщенный шифр (все остальное)

---

### Пример работы алгоритма (4)

Подшипник роликовый тип 102 <u>исп.1</u> ГОСТ 8328-75 М5х20-4.8-Z

- [ ] код стандарта (начинается с "ГОСТ", "DIN", ...)
- [ ] код типа (начинается с "тип", "типа", ...)
- [x] код исполнения (начинается с "исп.", "исполнение", ...)
- [ ] код класса точности (начинается с "класс точности", ...)
- [ ] слово на естественном языке (только кириллица/латиница)
- [ ] обобщенный шифр (все остальное)

---

### Пример работы алгоритма (5)

Подшипник роликовый тип 102 исп.1 <u>ГОСТ 8328-75</u> М5х20-4.8-Z

- [x] код стандарта (начинается с "ГОСТ", "DIN", ...)
- [ ] код типа (начинается с "тип", "типа", ...)
- [ ] код исполнения (начинается с "исп.", "исполнение", ...)
- [ ] код класса точности (начинается с "класс точности", ...)
- [ ] слово на естественном языке (только кириллица/латиница)
- [ ] обобщенный шифр (все остальное)

---

### Пример работы алгоритма (6)

Подшипник роликовый тип 102 исп.1 ГОСТ 8328-75 <u>М5х20-4.8-Z</u>

- [ ] код стандарта (начинается с "ГОСТ", "DIN", ...)
- [ ] код типа (начинается с "тип", "типа", ...)
- [ ] код исполнения (начинается с "исп.", "исполнение", ...)
- [ ] код класса точности (начинается с "класс точности", ...)
- [ ] слово на естественном языке (только кириллица/латиница)
- [x] обобщенный шифр (все остальное)

---

## Основной цикл

```golang
for offset := 0; offset < len(text); {
	for ; offset < len(text) && text[offset] == ' '; offset++ {}
	
	for _, blockParser := range blockParsers {
		parser := blockParser.Start()
		parsedCount := 0
		for i := offset; i < len(text); i++ {
			if parser.Handle(i, text[i]) {
				parsedCount++
			} else {
				break
			}
		}
		if parser.IsFinished() {
			keywords = append(keywords, parser.Get(text)...)
			offset += parsedCount
			break
		}
	}
}
```

---

### Конфигурация конечного автомата

```golang
var codePattern = pattern{
	initialState: {
		{condition: exact('г'), target: "гост_г", isCharIgnored: true},
		{condition: exact('d'), target: "din_d", isCharIgnored: true},
		{condition: exact('т'), target: "ту_т", isCharIgnored: true},
		{condition: exact('с'), target: "сто_с", isCharIgnored: true},
		{condition: exact('о'), target: "ост_о", isCharIgnored: true},
		{condition: exact('и'), target: "исполнение_и", isCharIgnored: true},
		{condition: exact('к'), target: "класс_точности_к", isCharIgnored: true},
	},
	"гост_г": {{condition: exact('о'), target: "гост_о", isCharIgnored: true}},
	"гост_о": {{condition: exact('с'), target: "гост_с", isCharIgnored: true}},
	"гост_с": {{condition: exact('т'), target: "гост_т", isCharIgnored: true}},
	"гост_т": {{condition: space{}, target: "гост_пробел", modifyResult: setStandardType(code.GOST), isCharIgnored: true}},
	"din_d":  {{condition: exact('i'), target: "din_i", isCharIgnored: true}},
	"din_i":  {{condition: exact('n'), target: "din_n", isCharIgnored: true}},
	"din_n":  {{condition: space{}, target: "din_пробел", modifyResult: setStandardType(code.DIN), isCharIgnored: true}},
	// ...
}
```

---

### Вариант с регулярными выражениями

```golang
var blockParsers = []*blockParser{
	{
		keywordType: code.StandardCode,
		subType:     code.GOST,
		pattern:     regexp.MustCompile(`^гост (р )?(\d+[-.\d+]*) `),
		index:       2,
	},
	// ...
	{
		keywordType: code.VersionCode,
		pattern:     regexp.MustCompile(`^(исп( |. ?)|исполнен(ия|ие) )(([а-внa-z]{1,3})|([а-внa-z]{0,3}\d+\S*)) `),
		index:       4,
	},
	// ...
	{
		keywordType: code.NaturalWord,
		pattern:     regexp.MustCompile("^([a-zа-я]+[-'`′a-zа-я]*) "),
		index:       1,
	},
	{
		keywordType: code.GenericCode,
		pattern:     regexp.MustCompile(`(\S+) `),
		index:       1,
	},
}
```

---

### Тестирование вариантов алгоритма

Для тестирования использовался встроенный Golang механизм benchmark

1) Базовая версия (шесть конечных автоматов, без предобработки строки)
2) Версия с предобработкой строки (нормализация пробелов)
3) Оптимизированный вариант (два конечных автомата, оптимизации)
4) Вариант на регулярных выражениях
5) Исходная версия алгоритма (проприетарная)

---

### Исходные данные тестов

1) Одна строка со всеми возможными паттернами
2) Последовательный разбор тестовых образцов (около 127 шт.)
3) Последовательный разбор реальных образцов (около 2500 шт.)

---

### Разбор полного образца

| Версия алгоритма | Время, ns/op | Память, B/op | Выделений памяти, allocs/op |
|------------------|-------------:|-------------:|----------------------------:|
| базовая          |        9 637 |        5 872 |                          92 |
| предобработка    |       11 592 |        5 488 |                          86 |
| оптимизированный |        7 710 |        2 856 |                          41 |
| regexp           |       16 421 |        2 446 |                          33 |
| исходный         |       25 965 |        9 498 |                         173 |

---

### Последовательный разбор всех тестовых образцов

| Версия алгоритма | Время, ns/op | Память, B/op | Выделений памяти, allocs/op |
|------------------|-------------:|-------------:|----------------------------:|
| базовая          |      116 660 |       41 832 |                         863 |
| предобработка    |      142 590 |       47 144 |                         957 |
| оптимизированный |       97 680 |       25 992 |                         631 |
| regexp           |      204 595 |       27 011 |                         693 |
| исходный         |      356 495 |      112 458 |                       3 545 |

---

### Последовательный разбор настоящих образцов

| Версия алгоритма | Время, us/op | Память, KB/op | Выделений памяти, allocs/op |
|------------------|-------------:|--------------:|----------------------------:|
| базовая          |       18 294 |         7 930 |                     130 430 |
| предобработка    |       18 011 |         7 917 |                     129 945 |
| оптимизированный |       11 697 |         4 094 |                      63 696 |
| regexp           |       23 079 |         3 308 |                      51 065 |
| исходный         |       32 981 |        13 850 |                     260 962 |

---

### Выводы

- Вариант с двумя сложными автоматами получился наиболее быстрым. Однако, он
достаточно сложен в поддержке (нужно понимать как настроить конечный автомат).
- Вариант с регулярными выражениями наиболее простой для понимания. Интересно отметить,
что он так же получается более эффективным по памяти.

---

### Ссылки

<https://github.com/strider2038/otus-algo/pull/19/files>

![otus project](images/qr_otus_algo.gif "otus project")
