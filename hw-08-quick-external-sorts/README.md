# Домашнее задание №8 "Быстрая и внешняя сортировки"

## Цель

Реализовать рассмотренные алгоритмы сортировки и сравнить их эффективность.

## Задание

* [x] Реализовать алгоритм быстрой сортировки QuickSort.
* [x] Реализовать алгоритм сортировки слиянием MergeSort.
* [x] Написать функцию (N, T) для генерации текстового файла из N строчек, на каждой строке записано случайное число от
  1 до T.
* [x] Реализовать алгоритм внешеней сортировки ExternalSort первым способом, создание T разных файлов с последующим
  слиянием.
* [x] Реализовать алгоритм внешеней сортировки ExternalSort вторым способом, с двумя вспомогательными файлами, при
  первом проходе в память загружать блоки по 100 чисел, сортировать их любым другим алгоритмом и отправлять на выход, а
  потом объединять файлы с помощью алгоритма слияния.
* [x] Занести в сравнительную таблицу время сортировки файлов при:
    * N = 10^2, 10^3, 10^4, 10^5, 10^6,
    * T = 10, N. (всего 10 вариантов сочетания N и T).
* [x] Выполнить комплексное тестирование алгоритмов сортировки.

Протестировать алгоритмы на массивах размеров:
1, 10, 100, 1.000, 10.000, 100.000, 1.000.000, 10.000.000.

Алгоритм внешней сортировки в этом пункте тестировать не нужно.

И с различным характером данных:

* random - массив из случайных чисел
* digits - массив из случайных цифр
* sorted - на 99% отсортированный массив
* reverse - обратно-отсортированный массив

## Сравнение алгоритмов быстрой сортировки

### Quick sort с выбором крайнего правого значения как опорного

| N          | random   | digits   | sorted   | reverse  |
|------------|----------|----------|----------|----------|
| 1          | 305 ns   | 236 ns   | 158 ns   | 172 ns   |
| 10         | 419 ns   | 410 ns   | 3.1 µs   | 2.9 µs   |
| 100        | 3.5 µs   | 5.4 µs   | 14.4 µs  | 11.2 µs  |
| 1 000      | 40.9 µs  | 23.6 µs  | 95.5 µs  | 367.1 µs |
| 10 000     | 490.8 µs | 236.9 µs | 1.1 ms   | 11.45 ms |
| 100 000    | 5.7 ms   | 2.4 ms   | 11.1 ms  | 1.2 s    |
| 1 000 000  | 66.4 ms  | 26.6 ms  | 123.9 ms | ~        |
| 10 000 000 | 753.8 ms | 279.9 ms | 1.8 s    | ~        |

### Quick sort с выбором опорного значения по центру

| N          | random   | digits   | sorted   | reverse  |
|------------|----------|----------|----------|----------|
| 1          | 124 ns   | 270 ns   | 253 ns   | 326 ns   |
| 10         | 388 ns   | 411 ns   | 355 ns   | 340 µs   |
| 100        | 7.1 µs   | 22.8 µs  | 1.4 µs   | 1.2 µs   |
| 1 000      | 46.3 µs  | 38 µs    | 49.4 µs  | 9.7 µs   |
| 10 000     | 568.5 µs | 262.1 µs | 164.7 µs | 103.8 µs |
| 100 000    | 5.4 ms   | 2.4 ms   | 1.1 ms   | 1.1 ms   |
| 1 000 000  | 64.1 ms  | 26.7 ms  | 14 ms    | 12.8 ms  |
| 10 000 000 | 698.7 ms | 280.3 ms | 148.8 ms | 139.5 ms |

### Quick sort, вариант разделения Lomuto

| N          | random   | digits   | sorted   | reverse  |
|------------|----------|----------|----------|----------|
| 1          | 123 ns   | 193 ns   | 162 ns   | 112 ns   |
| 10         | 387 ns   | 322 ns   | 2.7 µs   | 4.3 µs   |
| 100        | 2.6 µs   | 20 µs    | 7.8 µs   | 20.8 µs  |
| 1 000      | 65.8 µs  | 102.9 µs | 203.3 µs | 891.5 µs |
| 10 000     | 518.5 µs | 4.9 ms   | 749.5 µs | 37 ms    |
| 100 000    | 5 ms     | 434.4 ms | 14.1 ms  | 3.7 s    |
| 1 000 000  | 63.2 ms  | 43.3 s   | 204.2 ms | ~        |
| 10 000 000 | 690.5 ms | ~        | 2.8 s    | ~        |

### Merge sort без оптимизации памяти

В данном варианте при слитии массивов память выделяется каждый раз.

| N          | random   | digits   | sorted   | reverse  |
|------------|----------|----------|----------|----------|
| 1          | 289 ns   | 153 ns   | 136 ns   | 112 ns   |
| 10         | 847 ns   | 703 ns   | 710 ns   | 605 ns   |
| 100        | 8 µs     | 7.9 µs   | 7.5 µs   | 4.1 µs   |
| 1 000      | 102.7 µs | 73.3 µs  | 41.4 µs  | 38.9 µs  |
| 10 000     | 1.1 ms   | 627.5 ms | 500.9 µs | 440.3 ms |
| 100 000    | 11.2 ms  | 6.5 ms   | 5.1 ms   | 4.7 ms   |
| 1 000 000  | 115.1 ms | 81.6 ms  | 64.1 ms  | 55.1 ms  |
| 10 000 000 | 1.2 s    | 821.6 ms | 663.9 ms | 651 ms   |

### Merge sort с буфером

В данном варианте алгоритма выделяется буфер с размером равным размеру входного массива.

| N          | random   | digits   | sorted   | reverse  |
|------------|----------|----------|----------|----------|
| 1          | 350 ns   | 220 ns   | 181 ns   | 227 ns   |
| 10         | 1 µs     | 623 ns   | 589 ns   | 419 ns   |
| 100        | 4 µs     | 8.4 µs   | 21.6 µs  | 2.1 µs   |
| 1 000      | 48.5 µs  | 52.7 µs  | 23.1 µs  | 46.8 µs  |
| 10 000     | 588.9 µs | 617.3 ms | 235.4 µs | 238.5 ms |
| 100 000    | 7.4 ms   | 4.8 ms   | 3.1 ms   | 2.3 ms   |
| 1 000 000  | 83.7 ms  | 48.8 ms  | 32.4 ms  | 28.7 ms  |
| 10 000 000 | 899 ms   | 529.7 ms | 362.1 ms | 324 ms   |

### Выводы по алгоритмам быстрой сортировки

* QuickSort
    * Наиболее быстрый алгоритм среди всех рассмотренных
    * Производительность зависит от характера распределения данных и принципа выбора опорного значения
    * Вариант с выбором опорного значения по центру показывает хорошие результаты для всех рассмотренных характеров
      распределения
    * Варианты с выбором опорного значения по правой границе не эффективен на отсортированных и обратно-отсортированных
      массивах
    * К удивлению, кажущийся более оптимальным вариант Lomuto оказывается менее эффективным более простого варианты с
      выбором опорного значения по правой границе
* MergeSort
    * По производительности сравним с Shell sort, в варианте с буфером превосходит его
    * Требует выделения памяти, равной размеру входного массива
    * Стабильно работает при любом характере распределения данных

## Тестирование алгоритмов внешней сортировки

### External sort, 2-way merge, выборка по 100 чисел

При первом проходе в память загружаются блоки по 100 чисел, сортируются
алгоритмом быстрой сортировки и записываются в два файла. Затем файлы итеративно
объединяются с помощью алгоритма слияния.

| N         | диапазон `[0, 10)` | диапазон `[0, N)` |
|-----------|--------------------|-------------------|
| 100       | 234.6 µs           | 199 µs            |
| 1 000     | 19.4 ms            | 6.6 ms            |
| 10 000    | 127.3 ms           | 123.8 ms          |
| 100 000   | 1.7 s              | 1.8 s             |
| 1 000 000 | 24 s               | 24.7 s            |

### External sort, k-way merge

Создаются K разных файлов с ограниченным размером по 100 чисел. Каждый файл сортируется
алгоритмом быстрой сортировки. Затем все файлы объединяются с помощью алгоритма k-way merge
с использованием min-кучи.

| N         | диапазон `[0, 10)` | диапазон `[0, N)` |
|-----------|--------------------|-------------------|
| 100       | 353.7 µs           | 356.5 µs          |
| 1 000     | 3.2 ms             | 3.2 ms            |
| 10 000    | 51.4 ms            | 36 ms             |
| 100 000   | 560.4 ms           | 525.2 ms          |
| 1 000 000 | 19.6 s             | 22.4 s            |

### Выводы

С помощью внешней сортировки можно производить сортировку чисел в условиях ограниченного
использования оперативной памяти. 

Алгоритм 2-way merge оказался более сложным для восприятия,
но он эффективен при жестких ограничениях памяти и требованиях к количеству открытых файлов
(необходимо всего 4 файловых дескриптора).

Алгоритм k-way merge при использовании такого же ограничения в 100 чисел показывает результаты
лучше, однако при работе с ним приходится использовать большое количество файловых
дескрипторов N/k.

## Запуск кода

Для запуска тестов необходимо распаковать архив с данными для тестов в директорию `testdata/sortdata`

Запуск тестов

```shell
go test -v ./...
```
