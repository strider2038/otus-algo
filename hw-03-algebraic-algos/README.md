# Домашнее задание №3 "Алгебраические алгоритмы"

## Цель

Написать и сравнить разные алгоритмы возведения числа в целую степень, вычисления чисел Фибоначчи и поиска простых чисел.

## Возведение числа в степень

Алгоритмы реализованы в пакете `power`.

* `Iterative` - итеративный O(N) алгоритм возведения числа в степень.
* `Logarithmic` - алгоритм возведения в степень через двоичное разложение показателя степени O(2LogN) = O(LogN).

Сравнение работы алгоритмов. Для наглядности добавлен алгоритм из пакета стандартной библиотеки `math.Pow`.

| N                | Итеративный | Логарифмический | `math.Pow` |
|------------------|-------------|-----------------|------------|
| 10               | 202 ns      | 144 ns          | 574 ns     |
| 100              | 106 ns      | 42 ns           | 190 ns     |
| 1000             | 441 ns      | 35 ns           | 114 ns     |
| 10000            | 3.929 µs    | 41 ns           | 146 ns     |
| 100000           | 38.625 µs   | 41 ns           | 177 ns     |
| 1000000          | 385.578 µs  | 42 ns           | 225 ns     |
| 10000000         | 3.822 ms    | 45 ns           | 332 ns     |
| 100000000        | 33.072 ms   | 46 ns           | 267 ns     |
| 1000000000       | 309.768 ms  | 47 ns           | 301 ns     |
| 10000000000      | 2.826 s     | 46 ns           | 242 ns     |
| 100000000000     | ~           | 48 ns           | 234 ns     |
| 1000000000000    | ~           | 46 ns           | 241 ns     |
| 10000000000000   | ~           | 62 ns           | 245 ns     |
| 100000000000000  | ~           | 65 ns           | 225 ns     |
| 1000000000000000 | ~           | 66 ns           | 221 ns     |

**Выводы**

Алгоритм возведения в степень через двоичное разложение показателя степени обладает высокой скоростью.
Интересно, что он время работы меньше при сравнении с алгоритмом из стандартной библиотеки.
Однако, следует учитывать, что в стандартной библиотеке степень числа задается в вещественном формате,
а в реализованном алгоритме используется целое число.

Так же следует отметить, что битовые операции дают небольшой выигрыш в скорости работы алгоритма
(исследовано с помощью benchmark-теста).

Например, вместо `n % 2 == 1` используется сравнение младшего бита `n & 1 == 1`, 
вместо `n = n / 2` - сдвиг вправо на один бит `n = n >> 1`.

## Вычисление чисел Фибоначчи

Алгоритмы реализованы в пакете `fibonacci`. Для работы с большими числами используется
пакет `big` из стандартной библиотеки.

* `Recursive` - рекурсивный O(2^N) алгоритм.
* `Iterative` - итеративный O(N) алгоритм.
* `ByMatrix` - алгоритм поиска чисел Фибоначчи O(LogN) через умножение матриц.

Сравнение работы алгоритмов.

| N        | Рекурсивный | Итеративный | Умножением матриц |
|----------|-------------|-------------|-------------------|
| 10       | 9.2 µs      | 1.1 µs      | 7.1 µs            |
| 20       | 1.3 ms      | 1.4 µs      | 6.5 µs            |
| 30       | 137.8 ms    | 2.1 µs      | 7.9 µs            |
| 40       | 16.1 s      | 3.1 µs      | 12.9 µs           |
| 50       | ~           | 3.2 µs      | 7.5 µs            |
| 100      | ~           | 7.1 µs      | 11.6 µs           |
| 1000     | ~           | 91.6 µs     | 20.1 µs           |
| 10000    | ~           | 1.9 ms      | 125.6 µs          |
| 100000   | ~           | 98.3 ms     | 4 ms              |
| 1000000  | ~           | 8.8 s       | 115.6 ms          |
| 10000000 | ~           | ~           | 5.1 s             |

**Выводы**

Рекурсивный алгоритм наиболее простой, но фактически не эффективный. Даже при малых N время вычисления
довольно велико.

Итеративный алгоритм достаточно простой и его можно эффективно использовать до N < 100000.

Наиболее эффективный алгоритм - алгоритм, основанный на умножении матриц. Однако, при малых N < 1000
он менее эффективен, чем итеративный алгоритм (из-за оверхеда на перемножение матриц).

Общая рекомендация - при N < 1000 следует использовать итеративный алгоритм, а при N > 1000 - алгоритм
на основе перемножения матриц.

## Поиск простых чисел

Алгоритмы реализованы в пакете `prime`.

* `CountByBruteForce` - алгоритм поиска количества простых чисел через перебор делителей, O(N^2).
* `CountByBruteForceOptimized` - алгоритм поиска количества простых чисел через перебор делителей с применением оптимизаций.
* `CountByPrimes` - алгоритм поиска простых чисел с оптимизациями поиска и делением только на простые числа, O(N * Sqrt(N) / Ln (N)).
* `CountBySieveOfEratosthenes` - алгоритм "Решето Эратосфена" для быстрого поиска простых чисел O(N Log Log N).
* `CountBySieveOfEratosthenesOptimized` - алгоритм "Решето Эратосфена" с оптимизацией памяти, с использованием битовой матрицы, с сохранением по 32 значения в одном int, биты хранятся только для нечётных чисел.

| N          | Перебором | Перебором+ | Деление на простые | Решето Эратосфена | Решето Эратосфена+ |
|------------|-----------|------------|--------------------|-------------------|--------------------|
| 10         | 510 ns    | 259 ns     | 585 ns             | 439 ns            | 395 ns             |
| 100        | 16.2 µs   | 2.2 µs     | 8.7 µs             | 683 ns            | 355 ns             |
| 1000       | 1.2 ms    | 41.3 µs    | 26.3 µs            | 4.4 µs            | 1.8 µs             |
| 10000      | 87 ms     | 939.6 µs   | 423.1 µs           | 21 µs             | 19.3 µs            |
| 100000     | 6.3 s     | 20.6 ms    | 5.9 ms             | 263.6 µs          | 313.3 µs           |
| 1000000    | ~         | 496.9 ms   | 112.8 ms           | 2.9 ms            | 2.4 ms             |
| 10000000   | ~         | 12.6 s     | 2.2 s              | 40.2 ms           | 26.3 ms            |
| 100000000  | ~         | ~          | ~                  | 712.8 ms          | 274.8 ms           |
| 1000000000 | ~         | ~          | ~                  | 8.2 s             | 4.9 s              |

**Выводы**

Оптимизации в алгоритме поиска простых чисел перебором дают явный выигрыш по сравнению с неоптимизированным вариантом.
Поэтому при реализации алгоритмов следует уделять внимание раннему выходу из цикла.

Следует иметь в виду, что алгоритмы поиска с делением только на простые числа и "Решето Эратосфена"
обладают сложностью по памяти. Для их работы необходимо резервировать память для массивов.

Если сравнивать простой перебор и переборы с памятью, то до N < 100000 выгоднее брать алгоритмы без выделения памяти,
т.к. они практически не уступают по времени работы. Для малых N алгоритмы с выделением памяти оказываются
медленнее простого перебора.

Наиболее эффективный алгоритм для N > 100000 - "Решено Эратосфена". Интересно отметить, что версия с оптимизацией
по памяти (использование битовой матрицы) так же дает выигрыш и по производительности при N > 1000000.
Скорее всего это связано с оверхедом переноса массивов из оперативной памяти в кеш процессора. Чем меньше массив,
тем меньше требуется времени для его переноса в кеш процессора. Поэтому использование битовых матриц
эффективнее с точки зрения работы алгоритма в общем случае.

Пример потребления памяти (вычислено с помощью benchmark-тестов).

* "Решето Эратосфена" для N = 10000000: выделяемая память около 10 Мб.
* "Решето Эратосфена" с битовой матрицей для N = 10000000: выделяемая память около 630 Кб.

## Запуск кода

Запуск примеров кода

```shell
go run main.go
```

Запуск тестов

```shell
go test -v ./...
```
