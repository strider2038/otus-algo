# Домашнее задание №10 "Двоичное дерево поиска, АВЛ и Декартово дерево"

## Цель

* Создать двоичное дерево поиска, реализовать один из вариантов балансировки.
* Сравнить эффективность алгоритмов на случайных и упорядоченных данных.

## Двоичное дерево поиска

### Задание

* Создать простейшее двоичное дерево поиска.
* Методы к реализации:
    * void insert(int x) - вставка элемента
    * bool search(int x) - поиск элемента
    * void remove(int x) - удаление элемента
* Протестировать работу алгоритма.
* Создать два дерева (максимальный размер дерева выберите такой, чтобы программа работала не дольше 1 минуты)
* Добавить N чисел в случайном (первое) и возрастающем (второе) порядке.
* Искать N/10 случайных чисел в каждом дереве.
* Удалить N/10 случайных элементов в каждом дереве.
* Заполнить таблицу производительности и сделать вывод.

### Сравнительная таблица

| N       | Поиск (random set) | Поиск (sorted set) | Удаление (random set) | Удаление (sorted set) |
|---------|--------------------|--------------------|-----------------------|-----------------------|
| 1 000   | 9.6 µs             | 64.5 µs            | 8.7 µs                | 62.9 µs               |
| 10 000  | 151 µs             | 7.6 ms             | 139 µs                | 9.1 ms                |
| 100 000 | 2.7 ms             | 842 ms             | 2.2 ms                | 1.1 s                 |

### Выводы

* При случайном заполнении бинарное дерево получается сбалансированным
    * Поиск и вставка элементов в сбалансированном дереве занимают примерно одинаковое время
    * Это соответствует оценке сложности в среднем O(log N)
* При заполнении отсортированными данными дерево вырождается в линейный список
    * Поиск и вставка медленнее
    * Соответствует времени поиска в линейном списке
    * Удаление в дереве сложнее, чем в линейном списке

## АВЛ дерево

### Задание

* Расширить класс из 1 части и создать сбалансированное АВЛ-дерево.
* Методы к реализации:
    * smallLeftRotation(Tree t)
    * smallRightRotation(Tree t) - малое левое/правое вращение
    * bigLeftRotation(Tree t)
    * bigRightRotation(Tree t) - большое левое/правое вращение, написать через вызов малых вращений
    * void insert(int x) - вставка элемента
    * void remove(int x) - удаление элемента
    * void rebalance(Tree t) - перебалансировка дерева
* Протестировать работу алгоритма аналогичным образом, дополнить таблицу производительности

### Сравнительная таблица

| N       | Поиск (random set) | Поиск (sorted set) | Удаление (random set) | Удаление (sorted set) |
|---------|--------------------|--------------------|-----------------------|-----------------------|
| 1 000   | 6.6 µs             | 6.4 µs             | 13.9 µs               | 11.4 µs               |
| 10 000  | 99 µs              | 101 µs             | 190 µs                | 158 µs                |
| 100 000 | 1.9 ms             | 2.2 ms             | 3.1 ms                | 2.8 ms                |

### Выводы

* За счет постоянной перебалансировки АВЛ-дерево нивелирует разницу между наполнением дерева
отсортированными данными и случайными.
* За счет сохранения оптимального баланса операции поиска по дереву эффективнее использования
несбалансированного дерева.
* С другой стороны, операции вставки и удаления требуют больших затрат. 
* Удаление примерно на 30-40% медленнее.
