# Домашнее задание №4 "Базовые структуры данных"

## Цель

Создание разных алгоритмов для реализации Динамического массива и сравнение их производительности. Создание приоритетной
очереди или неполного массива.

## Задача

1. Динамические массивы.
    1. Реализовать варианты динамических массивов: SingleArray, VectorArray, FactorArray, MatrixArray.
    2. Написать методы добавления и удаления элементов по индексу.
    3. Сравнить время выполнения операций.
2. Реализовать приоритетную очередь.

## Сравнение операций над динамическими массивами

### Добавление в конец Add

| N        | SingleArray | VectorArray(100) | FactorArray(2) | MatrixArray(100) | SliceArray |
|----------|-------------|------------------|----------------|------------------|------------|
| 100      | 39 µs       | 6.3 µs           | 10.8 µs        | 4.2 µs           | 3.5 µs     |
| 1000     | 1.9 ms      | 47 µs            | 23.9 µs        | 32.7 µs          | 18.6 µs    |
| 10000    | 49.4 ms     | 1.1 ms           | 314.2 µs       | 300.9 µs         | 272 µs     |
| 100000   | 11.4 s      | 68 ms            | 2.5 ms         | 6.2 ms           | 2.1 ms     |
| 1000000  | ~           | 11.9 s           | 17.8 ms        | 190 ms           | 23.7 ms    |

### Вставка в начало Insert(0)

| N      | SingleArray | VectorArray(100) | FactorArray(2) | MatrixArray(100) | SliceArray |
|--------|-------------|------------------|----------------|------------------|------------|
| 100    | 26.8 µs     | 9.4 µs           | 10.2 µs        | 204.1 µs         | 4.4 µs     |
| 1000   | 2 ms        | 266.7 µs         | 419.1 µs       | 23.9 ms          | 48.3 µs    |
| 10000  | 85.5 ms     | 25.5 ms          | 35.6 ms        | 2 s              | 4.6 ms     |
| 100000 | 14.4 s      | 2.7 s            | 2.8 s          | ~                | 787.4 ms   |

### Вставка в середину Insert(n/2)

| N      | SingleArray | VectorArray(100) | FactorArray(2) | MatrixArray(100) | SliceArray |
|--------|-------------|------------------|----------------|------------------|------------|
| 100    | 73.2 µs     | 11 µs            | 12.8 µs        | 107.8 µs         | 10.5 µs    |
| 1000   | 2 ms        | 206.5 µs         | 153.5 µs       | 10.1 ms          | 37.5 µs    |
| 10000  | 76.3 ms     | 13.5 ms          | 13.6 ms        | 1.03 s           | 1.8 ms     |
| 100000 | 9.8 s       | 1.4 s            | 1.4 s          | 1 m 31s          | 312.1 ms   |

### Удаление из начала Remove(0)

| N      | SingleArray | VectorArray(100) | FactorArray(2) | MatrixArray(100) | SliceArray |
|--------|-------------|------------------|----------------|------------------|------------|
| 100    | 3.8 µs      | 4.1 µs           | 7.2 µs         | 196.4 µs         | 1.3 µs     |
| 1000   | 277.7 ms    | 294.8 µs         | 311.1 µs       | 19.1 ms          | 34.2 µs    |
| 10000  | 27.2 ms     | 28.6 ms          | 28.6 ms        | 1.95 s           | 4.5 ms     |
| 100000 | 2.7 s       | 2.8 s            | 2.8 s          | 2 m 52 s         | 784 ms     |

### Удаление из середины Remove(n/2)

| N      | SingleArray | VectorArray(100) | FactorArray(2) | MatrixArray(100) | SliceArray |
|--------|-------------|------------------|----------------|------------------|------------|
| 100    | 2.5 µs      | 7.5 µs           | 5.1 µs         | 97.8 µs          | 1.3 µs     |
| 1000   | 138.3 ms    | 172.6 µs         | 146 µs         | 9.5 ms           | 23.2 µs    |
| 10000  | 13.4 ms     | 14 ms            | 13.6 ms        | 966 ms           | 1.7 ms     |
| 100000 | 1.4 s       | 1.4 s            | 1.4 s          | 1 m 26 s         | 312 ms     |

### Удаление из конца Remove(n-1)

| N      | SingleArray | VectorArray(100) | FactorArray(2) | MatrixArray(100) | SliceArray |
|--------|-------------|------------------|----------------|------------------|------------|
| 100    | 687 ns      | 663 ns           | 659 ns         | 2.5 µs           | 854 ns     |
| 1000   | 5.7 µs      | 5.8 µs           | 6.3 µs         | 33.1 µs          | 7.7 µs     |
| 10000  | 58.6 µs     | 54.4 µs          | 60.6 µs        | 247.5 µs         | 75.5 µs    |
| 100000 | 606.5 µs    | 897.2 µs         | 633.1 µs       | 2.5 ms           | 748 µs     |

### Выводы

Примечание. Во всех реализациях удаление элементов из массива не уменьшает фактического размера
массива. Если на операцию удаления делать физическое уменьшение массивов, то по производительности
она будет сравнима с операцией вставки.

На основе сравнительных таблиц можно сделать выводы о достоинствах и недостатках того 
или иного вида массива.

* SingleArray
  * Достоинства:
    * простота реализации
    * хорошая производительность любых операций при малых размерах N < 1000
  * Недостатки:
    * производительность резко падает при N > 1000
  * Применимость:
    * использование при редких операциях, приводящих к увеличению размера массива
    * достаточно удаления из конца массива
* VectorArray
  * Достоинства
    * простота реализации
    * хорошая производительность любых операций при средних размерах N < 1000*K, где K - размера вектора
  * Недостатки
    * производительность резко падает при N > 1000*K
  * Применимость:
    * эффективность зависит от частоты изменения размера массива и правильном подборе размера вектора K
    * размер массива растет линейно
* FactorArray
  * Достоинства
    * простота реализации
    * наиболее компромиссный вариант по производительности
  * Недостатки
    * экспоненциальный рост памяти, при больших N может резко "съесть всю память"
  * Применимость
    * в общем случае, если неизвестно как будет расти размер массива
    * эффективен если размер массива растет экспоненциально
* MatrixArray
  * Достоинства
    * при операциях добавления в конец более эффективное выделение памяти
    * аналогичен векторному массиву, важно подбирать размер K
  * Недостатки
    * не эффективен при операциях вставки в начало/середину и удаления из массива
  * Применимость
    * эффективность выделения памяти зависит от типа используемого массива
    * следует использовать только для операций добавления в конец
* SliceArray - обертка над слайсом (стандартный тип Golang на основе факторного массива)
  * Достоинства и недостатки аналогичны факторному массиву
  * По производительности немного лучше (по всей видимости, за счет внутренних оптимизаций)

## Реализация приоритетной очереди

Реализация предметной очереди написана на основе списка списков.

* Список с приоритетами - однонаправленный связный список с обходом.
  * Класс сложности вставки - O(N).
  * Класс сложности выборки - O(1).
* Элементы списка с приоритетами - однонаправленный связный список со ссылками на начало и конец.
  * Класс сложности вставки - O(1).
  * Класс сложности выборки - O(1).

## Запуск кода

Запуск примеров кода

```shell
go run main.go
```

Запуск тестов

```shell
go test -v ./...
```
