# Домашнее задание №15 "Префиксное дерево"

## Цель

Создать класс Trie с основными операциями над ассоциативным массивом.

## Задание

* Решить задачу: https://leetcode.com/problems/implement-trie-prefix-tree/
* Реализовать ассоциативный массив на основе Префиксного дерева.
* Сравнить эффективность добавления/поиска/удаления элементов в хэш-таблицу и в префиксное дерево.

## Реализация

* Реализация префиксного дерева представлена в пакете `trie`
* Реализация ассоциативного массива на основе префиксного дерева - в пакете `triearray`
* Дополнительно реализована версия префиксного дерева с оптимизацией по памяти в пакете `bittrie`

## Сравнение эффективности

### Запись N элементов

Для сравнения используется последовательное заполнение ассоциативного массива на N элементов.
Необходимо учитывать, что постепенное заполнение приводит к рехешированию хеш-таблиц.

Сравниваются четыре варианта:

* префиксное дерево (trie)
* префиксное дерево с оптимизацией памяти (bittrie)
* хеш-таблица с цепочками (chainmap)
* хеш-таблица из стандартной библиотеки (stdmap)

|         N |    trie | bittrie | chainmap | stdmap |
|----------:|--------:|--------:|---------:|-------:|
|       100 |  237 µs |   94 µs |    63 µs |  11 µs |
|     1 000 |  2.2 ms |  1.2 ms |   637 µs | 133 µs |
|    10 000 |   23 ms |  9.6 ms |   5.1 ms | 980 µs |
|   100 000 |  210 ms | 95.5 ms |  48.3 ms | 9.2 ms |
| 1 000 000 | 1.96  s |  925 ms |   783 ms | 208 ms |

Потребление памяти (приблизительно, без учета значений)

|         N |         trie |    bittrie |  chainmap |
|----------:|-------------:|-----------:|----------:|
|       100 |       279 KB |      39 KB |      3 KB |
|     1 000 |      2648 KB |     380 KB |     38 KB |
|    10 000 |    25 018 KB |   3 591 KB |    352 KB |
|   100 000 |   234 433 KB |  33 879 KB |  3 270 KB |
| 1 000 000 | 2 197 588 KB | 319 891 KB | 38 844 KB |

### Среднее время чтения

Среднее время чтения одного элемента из ассоциативного массива с N элементами.

|         N |   trie | bittrie | chainmap | stdmap |
|----------:|-------:|--------:|---------:|-------:|
|       100 | 138 ns |   75 ns |   187 ns |  33 ns |
|     1 000 | 169 ns |   87 ns |   215 ns |  34 ns |
|    10 000 | 380 ns |  104 ns |   196 ns |  43 ns |
|   100 000 | 588 ns |  149 ns |   210 ns |  45 ns |
| 1 000 000 | 660 ns |  236 ns |   308 ns |  94 ns |

## Выводы

Несмотря на то, что теоретически префиксное дерево кажется более быстрым по эффективности операций
по сравнению с хеш-таблицей (требуется меньшее количество операций для доступа к элементу), на
практике производительность оказывается хуже. По всей видимости, это вызвано тем, что для хеш-таблицы
требуется меньше операций для доступа к оперативной памяти: для доступа к элементу хеш-таблицы 
сначала надо вычислить адрес блока памяти (хеш от строки), а затем сразу обратиться к этому блоку памяти
(один раз выгрузить блок из оперативной памяти в кеш процессора). Для префиксного дерева же нужно 
последовательно пройтись по цепочке, т.е. выполнить ряд операций, которые будут каждый раз выгружать данные 
из оперативной памяти в кеш процессора.

В качестве оптимизации в работе предложен альтернативный вариант префиксного дерева (пакет `bittrie`).
Оптимизация заключается в том, что дочерние узлы хранятся в массиве переменной длины (в исходном алгоритме 
выделяется массив из N элементов). Для оптимизации доступа индексы дочерних узлов хранятся в отдельной
битовой маске. Таким образом класс сложности доступа к дочерним узлам остается O(1) вместо O(N)
в варианте когда необходимо перебирать все дочерние узлы.

Эффективность оптимизированного варианта показывает улучшение как по времени операций чтения/записи,
так и по памяти (выделяется примерно в 10 раз меньше памяти). Так же оптимизированный вариант
оказывается эффективнее хеш-таблицы из предыдущей домашней работы, однако немного уступает варианту
из стандартной библиотеки (разница кроется в алгоритме хеширования).

С другой стороны у префиксного дерева есть интересное преимущество над хеш-таблицей, заключающееся в том,
что можно обеспечить итерирование элементов в отсортированном порядке. Кроме того, есть возможность
выбрать поддерево на основе префикса.

## Запуск кода

Запуск тестов

```shell
go test -v ./...
```
